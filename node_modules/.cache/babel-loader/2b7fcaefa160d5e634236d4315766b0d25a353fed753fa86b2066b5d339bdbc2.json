{"ast":null,"code":"import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { supabase, TABLE_NAME } from '../supabaseClient';\n\n// Parses the `text` column (JSON string) into { keyword, description, url }\nexport function parseTextColumn(text) {\n  try {\n    return JSON.parse(text);\n  } catch {\n    return {\n      keyword: text,\n      description: '',\n      url: ''\n    };\n  }\n}\nexport const fetchKeywords = createAsyncThunk('keywords/fetchAll', async () => {\n  const {\n    data,\n    error\n  } = await supabase.from(TABLE_NAME).select('*').order('timestamp', {\n    ascending: false\n  });\n  if (error) throw new Error(error.message);\n  return data;\n});\nconst keywordsSlice = createSlice({\n  name: 'keywords',\n  initialState: {\n    items: [],\n    // raw rows from Supabase: [{ id, timestamp, text }, ...]\n    loading: false,\n    error: null\n  },\n  reducers: {\n    // Called when a real-time INSERT arrives\n    addKeyword: (state, action) => {\n      state.items.unshift(action.payload);\n    }\n  },\n  extraReducers: builder => {\n    builder.addCase(fetchKeywords.pending, state => {\n      state.loading = true;\n      state.error = null;\n    }).addCase(fetchKeywords.fulfilled, (state, action) => {\n      state.loading = false;\n      state.items = action.payload;\n    }).addCase(fetchKeywords.rejected, (state, action) => {\n      state.loading = false;\n      state.error = action.error.message;\n    });\n  }\n});\nexport const {\n  addKeyword\n} = keywordsSlice.actions;\n\n// Returns all rows sorted latest-first, with text parsed into keyword/description/url\nexport const selectAllKeywords = state => {\n  const {\n    items\n  } = state.keywords;\n  if (!items || items.length === 0) return [];\n  return [...items].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp)).map(row => {\n    var _parsed$keyword, _parsed$description, _parsed$url;\n    const parsed = parseTextColumn(row.text);\n    return {\n      id: row.id,\n      timestamp: row.timestamp,\n      keyword: (_parsed$keyword = parsed.keyword) !== null && _parsed$keyword !== void 0 ? _parsed$keyword : '',\n      description: (_parsed$description = parsed.description) !== null && _parsed$description !== void 0 ? _parsed$description : '',\n      url: (_parsed$url = parsed.url) !== null && _parsed$url !== void 0 ? _parsed$url : ''\n    };\n  });\n};\nexport default keywordsSlice.reducer;","map":{"version":3,"names":["createSlice","createAsyncThunk","supabase","TABLE_NAME","parseTextColumn","text","JSON","parse","keyword","description","url","fetchKeywords","data","error","from","select","order","ascending","Error","message","keywordsSlice","name","initialState","items","loading","reducers","addKeyword","state","action","unshift","payload","extraReducers","builder","addCase","pending","fulfilled","rejected","actions","selectAllKeywords","keywords","length","sort","a","b","Date","timestamp","map","row","_parsed$keyword","_parsed$description","_parsed$url","parsed","id","reducer"],"sources":["/Users/janielee/keyword-app/src/store/keywordsSlice.js"],"sourcesContent":["import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { supabase, TABLE_NAME } from '../supabaseClient';\n\n// Parses the `text` column (JSON string) into { keyword, description, url }\nexport function parseTextColumn(text) {\n  try {\n    return JSON.parse(text);\n  } catch {\n    return { keyword: text, description: '', url: '' };\n  }\n}\n\nexport const fetchKeywords = createAsyncThunk('keywords/fetchAll', async () => {\n  const { data, error } = await supabase\n    .from(TABLE_NAME)\n    .select('*')\n    .order('timestamp', { ascending: false });\n\n  if (error) throw new Error(error.message);\n  return data;\n});\n\nconst keywordsSlice = createSlice({\n  name: 'keywords',\n  initialState: {\n    items: [],    // raw rows from Supabase: [{ id, timestamp, text }, ...]\n    loading: false,\n    error: null,\n  },\n  reducers: {\n    // Called when a real-time INSERT arrives\n    addKeyword: (state, action) => {\n      state.items.unshift(action.payload);\n    },\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(fetchKeywords.pending, (state) => {\n        state.loading = true;\n        state.error = null;\n      })\n      .addCase(fetchKeywords.fulfilled, (state, action) => {\n        state.loading = false;\n        state.items = action.payload;\n      })\n      .addCase(fetchKeywords.rejected, (state, action) => {\n        state.loading = false;\n        state.error = action.error.message;\n      });\n  },\n});\n\nexport const { addKeyword } = keywordsSlice.actions;\n\n// Returns all rows sorted latest-first, with text parsed into keyword/description/url\nexport const selectAllKeywords = (state) => {\n  const { items } = state.keywords;\n  if (!items || items.length === 0) return [];\n\n  return [...items]\n    .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))\n    .map((row) => {\n      const parsed = parseTextColumn(row.text);\n      return {\n        id: row.id,\n        timestamp: row.timestamp,\n        keyword: parsed.keyword ?? '',\n        description: parsed.description ?? '',\n        url: parsed.url ?? '',\n      };\n    });\n};\n\nexport default keywordsSlice.reducer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}