{"ast":null,"code":"import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { supabase, TABLE_NAME } from '../supabaseClient';\nfunction parseKeywordColumn(raw) {\n  try {\n    return JSON.parse(raw);\n  } catch {\n    return {\n      keyword: raw,\n      description: '',\n      url: ''\n    };\n  }\n}\nfunction mockUrl(keyword) {\n  return `https://en.wikipedia.org/wiki/${encodeURIComponent(keyword)}`;\n}\nexport const fetchKeywords = createAsyncThunk('keywords/fetchAll', async () => {\n  const {\n    data,\n    error\n  } = await supabase.from(TABLE_NAME).select('*').order('created_at', {\n    ascending: false\n  });\n  if (error) throw new Error(error.message);\n  return data;\n});\nconst keywordsSlice = createSlice({\n  name: 'keywords',\n  initialState: {\n    items: [],\n    loading: false,\n    error: null\n  },\n  reducers: {\n    addKeyword: (state, action) => {\n      state.items.unshift(action.payload);\n    }\n  },\n  extraReducers: builder => {\n    builder.addCase(fetchKeywords.pending, state => {\n      state.loading = true;\n      state.error = null;\n    }).addCase(fetchKeywords.fulfilled, (state, action) => {\n      state.loading = false;\n      state.items = action.payload;\n    }).addCase(fetchKeywords.rejected, (state, action) => {\n      state.loading = false;\n      state.error = action.error.message;\n    });\n  }\n});\nexport const {\n  addKeyword\n} = keywordsSlice.actions;\n\n// Returns all rows sorted latest-first\nexport const selectAllKeywords = state => {\n  const {\n    items\n  } = state.keywords;\n  if (!items || items.length === 0) return [];\n  const INVALID = new Set(['', 'na', 'no', 'none', 'n/a']);\n  return [...items].sort((a, b) => new Date(b.created_at) - new Date(a.created_at)).map(row => {\n    var _parsed$keyword, _parsed$description;\n    const parsed = parseKeywordColumn(row.keyword);\n    const keywordLower = ((_parsed$keyword = parsed.keyword) !== null && _parsed$keyword !== void 0 ? _parsed$keyword : '').trim().toLowerCase();\n    return {\n      id: row.id,\n      timestamp: row.created_at,\n      keyword: keywordLower,\n      description: (_parsed$description = parsed.description) !== null && _parsed$description !== void 0 ? _parsed$description : '',\n      url: parsed.url || mockUrl(keywordLower)\n    };\n  }).filter(kw => !INVALID.has(kw.keyword));\n};\nexport default keywordsSlice.reducer;","map":{"version":3,"names":["createSlice","createAsyncThunk","supabase","TABLE_NAME","parseKeywordColumn","raw","JSON","parse","keyword","description","url","mockUrl","encodeURIComponent","fetchKeywords","data","error","from","select","order","ascending","Error","message","keywordsSlice","name","initialState","items","loading","reducers","addKeyword","state","action","unshift","payload","extraReducers","builder","addCase","pending","fulfilled","rejected","actions","selectAllKeywords","keywords","length","INVALID","Set","sort","a","b","Date","created_at","map","row","_parsed$keyword","_parsed$description","parsed","keywordLower","trim","toLowerCase","id","timestamp","filter","kw","has","reducer"],"sources":["/Users/janielee/keyword-app/src/store/keywordsSlice.js"],"sourcesContent":["import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\nimport { supabase, TABLE_NAME } from '../supabaseClient';\n\nfunction parseKeywordColumn(raw) {\n  try {\n    return JSON.parse(raw);\n  } catch {\n    return { keyword: raw, description: '', url: '' };\n  }\n}\n\nfunction mockUrl(keyword) {\n  return `https://en.wikipedia.org/wiki/${encodeURIComponent(keyword)}`;\n}\n\nexport const fetchKeywords = createAsyncThunk('keywords/fetchAll', async () => {\n  const { data, error } = await supabase\n    .from(TABLE_NAME)\n    .select('*')\n    .order('created_at', { ascending: false });\n\n  if (error) throw new Error(error.message);\n  return data;\n});\n\nconst keywordsSlice = createSlice({\n  name: 'keywords',\n  initialState: {\n    items: [],\n    loading: false,\n    error: null,\n  },\n  reducers: {\n    addKeyword: (state, action) => {\n      state.items.unshift(action.payload);\n    },\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(fetchKeywords.pending, (state) => {\n        state.loading = true;\n        state.error = null;\n      })\n      .addCase(fetchKeywords.fulfilled, (state, action) => {\n        state.loading = false;\n        state.items = action.payload;\n      })\n      .addCase(fetchKeywords.rejected, (state, action) => {\n        state.loading = false;\n        state.error = action.error.message;\n      });\n  },\n});\n\nexport const { addKeyword } = keywordsSlice.actions;\n\n// Returns all rows sorted latest-first\nexport const selectAllKeywords = (state) => {\n  const { items } = state.keywords;\n  if (!items || items.length === 0) return [];\n\n  const INVALID = new Set(['', 'na', 'no', 'none', 'n/a']);\n\n  return [...items]\n    .sort((a, b) => new Date(b.created_at) - new Date(a.created_at))\n    .map((row) => {\n      const parsed = parseKeywordColumn(row.keyword);\n      const keywordLower = (parsed.keyword ?? '').trim().toLowerCase();\n      return {\n        id: row.id,\n        timestamp: row.created_at,\n        keyword: keywordLower,\n        description: parsed.description ?? '',\n        url: parsed.url || mockUrl(keywordLower),\n      };\n    })\n    .filter((kw) => !INVALID.has(kw.keyword));\n};\n\nexport default keywordsSlice.reducer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}